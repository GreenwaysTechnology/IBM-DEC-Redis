
ES 6 - Concepts and implementation

Node js

Microservices using Node js :Moleculer

/////////////////////////////////////////////////////////////////////////////////////

Lab ;

1.node.js
2.vs code : editor

/////////////////////////////////////////////////////////////////////////////////////////

open vs code : code  .

///////////////////////////////////////////////////////////////////////////////////////////

ES 6 ;

What is es 6?

ecma script 6 
es 6 is version of javascript.


javascript is programming language.

javascript is object based,functional style,event driven pl.

javascript follows 3 major programming paradigms. =hybrid.

javascript is invented for web docment manupulation : DOM Programming. 
  javascript web script.

now a days javascript is every where , after 2008, after node was introduced

 -web document maniulation : UI programming - jquery,angular,react,vue

 -web application  - node js -  express,loopback,.....

 -distributed application(microservices) - node js -molecular....

javascript has versions and javascript standarized by Committe "ECMA international committe".

js---1.0 es 1.0

es 3 -1999

es 4 -2007

es 5 -2008

es 6 -2012 --->2015

es 7,es 8.....

////////////////////////////////////////////////////////////////////////////////////////////

js language


js is dynamic typed pl. data types are under stood in the runtime.


es 5/ es 6
1.language fundamentals
   -variables and literals
   -operators
   -loops,
   -constrol structure
2.functions
   fp programming
3.object based programming
   objects
4.dom programming
 
5.networking programming


//how to declare variables
/**
 * ways 
 * using var keyword -> es 5
 * using let and const keywords - es 6
 *   let and const is replacer for var
 *  if you are building application based on es 6 always
 * recommended to let / const
 *  * using this keywords
 * 
 * java code is running on jvm(runtime)
 *   -sun,oracle,openjdk,zuel,HP,ibm
 * javascript code is running on javascript runtime
 *  -classified into two category
 *   -embeded : inside another software:(browser)
 *   -standalone : node js
 * 
 * vendors:
 *   -chrome : v8
 *   -firefox : spidermonkey
 *   -opera : operaEngine
 *  - ie - chakara
 * 
 * nodejs
 *  -v8
 * 
 * Version combability:
 *  jvm -5 --if you run java 8 will work -? wont
 * 
 *  js engine certified by es 5----will support only es 5 features
 *  suppose not means---y cant
 *    convert es 6 code into es 6 : transipling /compilation : converting es 6 code into
 *   es 5 code and run.
 * 
 * should i do this every time, yes!!! -best practice
 * 
 * good thing, modern browsers  and node supports es 6 directly.
 * 
 */
//variable declarion
//var is keyword 
//firstName is variable
//"Subramanian" : literal
/**
 * types of literal
 *  string
 *  number
 *  boolean
 *  undefined
 *  NaN
 *  infinity
 *  null
 * function
 * object 
 */

//string : " " ,'' ,``
//var firstName = "Subramanian";
let firstName = "Subramanain";

//var lastName = 'Murugan';
let lastName = "Murugan";

console.log("firstName " + firstName);
console.log("firstName ", firstName);

//es 6 template literal : ``
console.log(`firstName ${firstName}  lastName ${lastName}`);

//backtick for multi line string literal :
// var title = 'IBM digital'
let title = 'IBM digital'

//es 5 style
let htmlDoc = "<html>" +
    "<head>" +
    "<title>" + title + "</title>"
"<body>" +
    "</body></html>";
console.log(htmlDoc)
//es 6 style
let htmlDocNew = `
    <html>
    <head>
       <title>${title}</title>
    </head>
    <body>

    </body>
    </html>
`;
console.log(htmlDocNew)
///////////////////////////////////////////////////////////////////////////////
//undefined; variable is declarated but no valid values, js initalizes undefined
//undefined itself is value only.

//undefined
let covid19todaysCount;
console.log(`covid19todaysCount ${covid19todaysCount}`)

//////////////////////////////////////////////////////////////////////////////////
//numbers : number,NaN,infinity

//number : 64 bit : double
let totalDischarged = 12300;
console.log(`totalDischarged ${totalDischarged}`)

//computation
let totalPatientsInHosiptal = 55000 - totalDischarged;
console.log(`totalPatientsInHosiptal ${totalPatientsInHosiptal}`)

//comuputational error : NaN : not a number: error code ,thrown by js when something 
//went wrong duration numerical operations.

//NaN and undefined
let qty; //undefined
let unitprice = 100;
let totalValue = qty * unitprice; // undefined * number==>error-NaN
console.log(`Total Value ${totalValue}`)

//NaN and type conversion
//string to number conversion
//implicit and explicit
//conversion
// let stockValue = "1000" // string but value is number
// let totalStockValue = stockValue * 100; //conversion happens first then computation: implicit
// console.log(`totalStockValue ${totalStockValue}`)

let stockValue = "$1000" // string but value is number
let totalStockValue = stockValue * 100; //conversion failed,throwing NaN
console.log(`totalStockValue ${totalStockValue}`)

//inifity
let avgDeathRate = 55000 / 0;
console.log(`avgDeathRate ${avgDeathRate}`)
///////////////////////////////////////////////////////////////////////////////////
//booleans
let isActive = true;
console.log(`Active ${isActive}`)
///////////////////////////////////////////////////////////////////////////////////
//Advanced booleans: which is true and which is false

/**
 * in js every thing is true except the following values
 * 
 *  1.boolean false
 *  2."",''(empty string)
 *  3.0 
 *  4.undefined
 *  5.NaN
 *  6.null
 * 
 */

let message = "hi";
//if(boolean);
if (message) {
    console.log("ok!")
} else {
    console.log("not ok!")
}
let count = 0;
if (count) {
    console.log("Count ok!")
} else {
    console.log("Count not ok!")
}
//////////////////////////////////////////////////////////////////////////////
//operators
//comparsional operator : == , === != , !==

let a = "10"; //string
let b = 10; //number

let result1 = a == b; // string == number : wrong comparasion
let result2 = a === b; //right comparsion
console.log(`${result1} ${result2} `);

//best pratice : when ever you compare use always : ===
/////////////////////////////////////////////////////////////////////////
// ? : tenary : to replace if conditions

message ? console.log('message ok') : console.log('message not oke');
(a === b) ? console.log('a and b ar equal') : console.log('a and b not equal');
///////////////////////////////////////////////////////////////////////////////////
// || && operators

let isEnabled = true;
let status = isEnabled || isActive;
console.log(status ? 'success' : 'failure');

let init = 12;
//if first operand(init) is truthy, the result would be first
// else result would be second one
//&& is opposit formula to or so you can test yourself
let start = init || 10;
console.log(`Start ${start}`)

///////////////////////////////////////////////////////////////////////////////
//typeof operator ; returns the type of variable
console.log(typeof "hello")
console.log(typeof message)
//number,infinity,NaN
console.log(typeof totalValue)
console.log(typeof avgDeathRate)
/////////////////////////////////////////////////////////////////////////////////

//other operators : new,instance of , for...in,[],.

///////////


//const 
//let and const both are same

let firstName = 'subramanian';
console.log(`FirstName ${firstName}`);
//re initalize
firstName = 'Ram'
console.log(`FirstName ${firstName}`);

//const never allows to reinitalize the variables
const pi = 3.14
console.log(`PI ${pi}`);
pi = 89.90;


////////////////////////////////////////////////////////////////////////////////////////////

functional programming:

function is logical representation of organization of code in js.

function in es6 and es 5:


//functions
//declaration
/**
 * normal delcaration
 * literal declaration
 */
//function declaration

function sayHello() {
    //function body
    console.log('hello');
}
//invoke function
sayHello();

//some logic inside function
function calculator() {
    let a = 10;
    let b = 90;
    let result = a + b;
    console.log(`Result ${result}`)
}
calculator();
//parameters and args
//a and b are args
//es 6 has feature called "default args"
function add(a = 1, b = 1) {
    let result = a + b;
    console.log(`Result ${result}`)
}
//10,10 are parameters
add(10, 10)
add();//undefined,undefined

//i want to pass more parameters , i dont this in advance
//Rest operator
function logger(...logs) {
    // console.log(arguments)
    console.log(logs)
}
logger('msapp', 'warning')
logger('msapp')
logger('msapp', 'y', 'x', 'err')
//////////////////////////////////////////////////////////////////////////
// function multiply() {
//     return 10 * 10;

// }
function multiply(a = 1, b = 1) {
    return a * b;

}
console.log(multiply(34, 89))

function isValid() {
    return; // undefined==false
}
isValid() ? console.log('Valid') : console.log('InValid')




//functtion literal
/**
 * in js function is value.
 * since it is value can be assigned to variable.
 * since it is value can be passed as parameter to another function
 * since it is value can be returned from another function.
 */
//function declaration using literal
//let is keyword
//a is variable
//10 is numeric literal
let a = 10;

//function is assigned into a variable , that variable can be used to invoke that
//function
let add = function (a = 1, b = 1) {
    let result = a + b;
    console.log(result);
}
add();

let multiply = function (a = 1, b = 1) {
    return a * b;
}
console.log(multiply(12,34))


////////////////////////////////////////////////////////////////////////////////////////////

es 6 representation of function: arrow function

//Arrow function : replacment of es 5 function literals


// pattern 1: simple arrow

// let hello = function () {
//     console.log('hello');
// }
let hello = () => {
    //function body
    console.log('hello');
}
hello();
//pattern 2: only one line of body,remove {}
let hai = () => console.log('hai');
hai();
//pattern 3: parameters and args : multi parameter with default args
let add = (a = 1, b = 2) => {
    let res = a + b;
    console.log(res);
}
add(39, 78)
//Pattern 4;single parameter without default args,drop ()
let greet = message => console.log(message);
greet('Hello')
//pattern 4: return values
let getValue = () => {
    return 100;
}
console.log(getValue());
//pattern 5: only return, no more body : remove {} and return statement
let getName = () => "Subramanian";
console.log(getName());
////pattern 6: args and return: single arg no default args, return the same
let getStatus = status => status;
console.log(getStatus(true))

//////////////////////////////////////////////////////////////////////////////////////////

function as parameter and function returning

//function as parameter: function can be passed into another function as parameter
//because function is just literal.

//a =10
//a = x;
function add(a, b) {
    return a + b;
}
//values directly
console.log(add(10, 90))
//via variables
let x = 10;
let y = 90;
console.log(add(x, y))



//function parameters
//connect is just variable, can hold any value(literal)
//connect = webServerConnect =function () {
//     console.log('webServer')
// };
function connectServer(server, connect) {
    const statuscode = connect(server);
    console.log(`status ${statuscode}`)
}

//via variables
let webServerConnect = function (server) {
    console.log(server)
    return `SUCCESS 200`
};
connectServer('HTTP Server is Running', webServerConnect);
//anonmous function : function with out name
connectServer('Database Server is Running', function (server) {
    console.log(server)
    return `SUCCESS 200`
});

//function as parameter: function can be passed into another function as parameter
//because function is just literal.

// function connectServer(server, connect) {
//     const statuscode = connect(server);
//     console.log(`status ${statuscode}`)
// }

// //via variables
// let webServerConnect = function (server) {
//     console.log(server)
//     return `SUCCESS 200`
// };
// connectServer('HTTP Server is Running', webServerConnect);
// //anonmous function : function with out name
// connectServer('Database Server is Running', function (server) {
//     console.log(server)
//     return `SUCCESS 200`
// });

const connectServer = (server, connect) => {
    const statuscode = connect(server)
    console.log(`status ${statuscode}`)
}

let webServerConnect = server => {
    console.log(server)
    return '200 SUCCESS'
};
connectServer('HttpServer', webServerConnect);

connectServer('SQL server', server => {
    console.log(server)
    return '200 SUCCESS'

});


//how to return function from another function

function counter() {
    console.log('counter')
    //inner function
    // return function increment() {
    //     console.log('increment')
    // }

    // //anonmous function
    return function (value) {
        console.log('increment')
        return value;
    }
    // //increment()
}
//inc is pointer to function:
// const inc = counter();
// console.log(inc(100));
console.log(counter()(1222))

//arrow version
// const counterNew = () => {
//     console.log('counter')
//     return value => `increment ${value}`;
// }
// const counterNew = () => {
//     return value => `increment ${value}`;
// }
const counterNew = () => value => `increment ${value}`;

// const inc1 = counterNew();
// console.log(inc1(100));
console.log(counterNew()(9000))
/////////////////////////////////////////////////////////////////////////////////

//curry function:function returns another function which returns another function and so...on

// function makeCake(milk) {
//     return function (cream) {
//         return function (sugar) {
//             return function (color) {
//                 return `${milk} ${cream} ${sugar} ${color}`
//             }
//         }
//     }
// }

// const makeCake = milk => {
//     return cream => {
//         return sugar => {
//             return color => {
//                 return `${milk} ${cream} ${sugar} ${color}`
//             }
//         }
//     }
// }
const makeCake = milk => cream => sugar => color => `${milk} ${cream} ${sugar} ${color}`

console.log(makeCake('cow milk')('cho cream')('brown sugar')('red'))




//closure : if outer is terminated but still inner will access outter function variables
//and args.

function counter(seedvalue = 1) {

    //outer function variable
    let count = seedvalue;
    return function () {
        //access outter function variable: closure
        return count++;
    }
}
let inc = counter(5)
console.log(inc());
console.log(inc());
console.log(inc());
console.log(inc());
console.log(inc());
console.log(inc());
console.log(inc());
console.log(inc());
console.log(inc());
console.log(inc());

///////////////////////////////////////////////////////////////////////////////////////

Object based concepts:


Object : memory => object state,object identity,object behaviour.

How to create Object?

Object template =class =>js class free object based language.

Two ways of creating object

1.constructor pattern
   calling constructors
    ->function
    -es 6 class
2.literal pattern




//object based programming

//object template : function

function Employee() {
    //state instance variable
    this.id = 1;
    this.name = 'subramanian';
    //methods
    this.calculateSalary = function () {
        return 1000;
    }
}
//object creation
//emp is just variable, new is operator,Employee() is constructor call
let emp = new Employee();
console.log(`id ${emp.id} Name ${emp.name} salary ${emp.calculateSalary()} `)

// ES 6 CLASSES
class Customer {
    id = 1;
    name = 'subramanian';
    //methods
    calculateInvoice() {
        return 1000;
    }
}

let cust = new Customer();
console.log(`id ${cust.id} Name ${cust.name} Invoice ${cust.calculateInvoice()} `)


//////////////////////////////////////////////////////////////////////////////////////////////
state initalization:
...................
1.hard coded way
2.after object creation
3.constructor parameters



// state : update

function Employee(id = 1, name = 'subramanian') {
    //state instance variable
    this.id = id //1;
    this.name = name //'subramanian';
    //methods
    this.calculateSalary = function () {
        return 1000;
    }
}
//object creation
//emp is just variable, new is operator,Employee() is constructor call
let emp = new Employee(45, 'john');

console.log(`id ${emp.id} Name ${emp.name} salary ${emp.calculateSalary()} `)

//after object creation
emp.name = 'ram'

console.log(`id ${emp.id} Name ${emp.name} salary ${emp.calculateSalary()} `)

// ES 6 CLASSES
class Customer {

    constructor(id = 1, name = 'subramanian') {
        this.id = id;//1;
        this.name = name;//'subramanian';
    }
    //methods
    calculateInvoice() {
        return 1000;
    }
}

let cust = new Customer(90, 'James');
console.log(`id ${cust.id} Name ${cust.name} Invoice ${cust.calculateInvoice()} `)

cust.name = 'ram';
console.log(`id ${cust.id} Name ${cust.name} Invoice ${cust.calculateInvoice()} `)
///////////////////////////////////////////////////////////////////////////////////////////

literal pattern:

//literal pattern

// const emp = {
//     id: 1,
//     name: 'subramanian',
//     calculateSalary: function () {
//         return 1000;
//     }
// }

// const emp = {
//     id: 1,
//     name: 'subramanian',
//     calculateSalary: () => 1000
// }
const emp = {
    id: 1,
    name: 'subramanian',
    calculateSalary() {
        return 1000
    }
}

console.log(`id ${emp.id} Name ${emp.name} salary ${emp.calculateSalary()} `)
///////////////////////////////////////////////////////////////////////////////////////////

Hierachy : object relationship : has-a , is-a(inheritance)



//inhertiance 
//has-a composition

class Customer {
    constructor(id = 1, name = 'Subrammanian') {
        this.id = id;
        this.name = name;
    }
}

class Account {

    constructor(accountNo, name, customer = new Customer()) {
        this.accountNo = accountNo;
        this.name = name;
        //has-a relationship
        this.customer = customer;

        console.log('account')
    }
    //method
    withdraw() {
        return 100;
    }
}
class SavingsAccount extends Account {
    constructor(accountNo, name) {
        super(accountNo, name);
        console.log('savings account!')
    }
    withdraw() {
        return 400 * super.withdraw();
    }
}
let sb = new SavingsAccount(1, 'Savings Account');
console.log(sb.accountNo, sb.name, sb.customer.id, sb.customer.name)
console.log(sb.withdraw())


//////////////////////////////////////////////////////////////////////////////////////

Object destrucing:
.................

//De Structure : breaking the object keys and make it simple

// function getEmployee(employee) {
//     console.log(`Id ${employee.id}`)
//     console.log(`Name ${employee.name}`)
//     console.log(`City ${employee.city}`)
//     console.log(`State ${employee.state}`)
// }

// function getEmployee(employee) {
//     //destructure
//     const { id, name, city, state } = employee;
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`City ${city}`)
//     console.log(`State ${state}`)
// }
// function getEmployee({ id, name, city, state, department: { depname, location } }) {
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`department ${depname} ${location}`)
//     console.log(`City ${city}`)
//     console.log(`State ${state}`)
// }
const getEmployee = ({ id, name, city, state, department: { depname, location } }) => {
    console.log(`Id ${id}`)
    console.log(`Name ${name}`)
    console.log(`department ${depname} ${location}`)
    console.log(`City ${city}`)
    console.log(`State ${state}`)
}
getEmployee({
    id: 1,
    name: 'subramanian',
    city: 'coimbatore',
    state: 'tamil nadu',
    department: {
        depname: 'Training',
        location: 'Banaglore'
    }
});
////////////////////////////////////////////////////////////////////////////////

const getCustomer = () => ({
    id: 1000,
    name: 'James',
    city: 'coimbatore',
    state: 'tamil nadu'
})


console.log(getCustomer())

//how to configure object property values dynamically

// const getVisitor = (id, name, city, state) => ({
//     id: id,
//     name: name,
//     city: city,
//     state: state
// })

//how to configure object property values dynamically

//objectKey: localvariable(funciton arg )
//if key and local variable is same :
// id:id,name:name => make it one , id,name
const getVisitor = (id, name, city, state) => ({
    id,
    name,
    city,
    state,
})


console.log(getVisitor(1000, 'John', 'Chennai', 'TN'))

/////////////////////////////////////////////////////////////////////////////////////////////
Modularity:
..........

code sharing

javascript language did not introduce file to file linking , file to file code sharing.

java:
 
folders and files

packages, import

package com.ibm.digital ===>com/ibm/digital/HomeService.java

Modularity started becoming important late 2000.

Js community wanted file and code sharing methods, they are introduced design patterns

module design patterns

1.NAMES PACE --- first design pattern --2001
2.AMD -Aync module design pattern -2002
3.CJS -common js design pattern -2006 :
   point : even today this design pattern is used
           node js implements this design pattern by default.

4.es6 modules -  2012--2015 
5.system --2016
6.umd --2017

/////////////////////////////////////////////////////////////////////////////////////////////

cjs design pattern


code sharing among files;

what is code?

code could be any thing(variables =can hold any literal,function,class)

how to link files?

cjs provides some keywords

for sharing and linking

sharing :
 exports
 module.exports

file linking
code          require('folder and filename') function
 |                          |
returnvalue                location 


src
  -mylib.js
   console.log('mylib')

 -index.js
	require('./mylib')


code sharing:
primitive : string,number,boolean

exports

src/index.js

//require returns code from mylib as object
//
// const result = require('./mylib')
// console.log(result);

// console.log(result.name);
// console.log(result.id)
// console.log(result.isActive)
// console.log(result.calculateScore())

//object destructuring

const { id, name, isActive, calculateScore } = require('./mylib')

console.log(name);
console.log(id)
console.log(isActive)
console.log(calculateScore())

src/mylib.js


//code sharing

exports.id = 1
exports.name = 'Subramanian';
exports.isActive = true;
exports.calculateScore = function () {
    return 10;
}

/////////////////////////////////////////////////////////////////////////////////////

Object augmentation:
...................

Objects are just simple datastructure ; map.

map -- key ;value

key:value
property:literal 

since object is ds, you can do some operations

add,delete,update,iterate

//Object augmentation
//add,remove,update,iterate object 

//empty object
let product = {};

//add new property
product.id = 10;
product.price = 900;
product.name = 'think pad'
product.qty = 90;

//update : js engine looks whether property exits or not, if exit update,else add
product.price = 870;

//remove property
delete product.qty

//iterate
//operator to access object properties 
// . operator : used only for known object property
// [] operator : used for accessing object property dynamically, which is unknown
for (const key in product) {
    console.log(key, product[key]);
}


console.log(product)
////////////////////////////////////////////////////////////////////////////////////////////

node has in built cjs loader.

browser has no any third loader(cjs,es6...)


//////////////////////////////////////////////////////////////////////////////////////////////

module.exports

1.which exports code as it is.
   Which does not add inside any object.
 if you return a variable, the variable will retuned as it.

2.per file only one module.exports allowed


src/data/customer-data.js


const CUSTOMERS = [{ id: 1, name: 'A1' },{ id: 2, name: 'A2' }]

module.exports = CUSTOMERS;

src/services/customerservice.js

/**
 * 
 * function require(fileName){
 * 
 * class CustomerService {
    constructor() {
        console.log('constructor is called')
    }
    findAll() {
        return [{ id: 1, name: 'A' }]
    }
}
    return CustomerService;
 * 
 * }
 */
const CUSTOMERS = require('../data/customer-data');

class CustomerService {
    constructor() {
        console.log('constructor is called')
    }
    findAll() {
        return CUSTOMERS;
    }
}
module.exports = CustomerService;

src/index.js
const { id, name, isActive, calculateScore } = require('./mylib')
const CustomerService = require('./services/CustomerService')


console.log(name);
console.log(id)
console.log(isActive)
console.log(calculateScore())
let service = new CustomerService();
console.log(service.findAll())
/////////////////////////////////////////////////////////////////////////////////////////////

What is node.js

Node is javascript platform and runtime to run javascript programms.

Js language features:

javascript is async programming language.

concurrency
  -doing multiple things at the same time.
threading : sub process
if you run many task at the same time-multi threading.

Does js support multithreading?
 No!--js single thread engine.

how to implement in concurrency in js?

runtime architecture

what is runtime ?
  program in excution => process.

program types:

1.passive program  
  the program which is not in main memory.
  the program which is main memory but not accessed by cpu.

2.active program

 the program which is in main memory accessed by cpu
 active program is other wise called process.

Point:

Any thing(program) inside ram will have structure.

Process structure====>runtime structure===> js engine structure==> Node structure

heap 
  dynamic memory segment used to allocate memory on fly for the running programms
stack
  dynamic memory segment used to allocate memory for "methods/functions"
program data
 -common passive data for running process
//////////////////////////////////////////////////////////////////////////////////////////////

stack:

function  sayHello(){
 ///logic 
  let name ='subramanian'
}

//Objective of function call
//to perform task , who will perform task=>cup
//cup will communicate always RAM

function call means , moving function to ram,Any thing(program) inside ram will have structure.
i need function structure, who will create/allocate function structure ?
       "stack"
sayHello();

How many frames can be run at the same time?

in general , you can run only one active frame.

can i run/create multiple frames?

Yes!....

what is frame?
  -thread

can i run multiple frames(threads) in javascript?

 No,

then how i can achive concurrency.

--->Worker-thread Model/
--->Event--Loop architecture/
--->Reactor Model/
/////////////////////////////////////////////////////////////////////////////////////

Sync Programming : single frame architecture

only one frame can be executed
while running one frame, other functions has to wait => "Blocking"

//blocking /sync programming

function sayHello() {
    console.log('hello');
}
function add(a = 1, b = 2) {
    let c = a + b;
    console.log(c);
}
//invoke functions
//sayhello---stack---frame is created---running|once done--frame is removed 
sayHello() 
//add--stack--frame is created---running|once done--frame is removed
add(10, 10);
//////////////////////////////////////////////////////////////////////////////////////////

What is the problems single frame arch?

 -frame takes longer time to complete, other programs will wait: blocking

frames should block other programs : Non blocking

 Async Progamming ;concurrency architecture

Async architecture is designed based on one design pattern "Reactor Design Pattern"

Worker-thread Model : dont create frame(thread) at the process level

funcall()-------stack---|---------------os kernal--thread is running--


how data is returned to end users once the task is completed?

  "Event driven architecture"

  Signal : completed,connected,closed......


Event Queue(Task Queue)
  It is data structure which has completed job references in the form of functions
    - callback functions : handler function :==>will have data to be retuned to end user


Event loop
    It is program which keeps on checking the queue whether any message should be
   processed : for what , in order to send results back to clients.


funcall()-------stack---|---------------os kernal--thread is running--Completed-->push into
 Event Queue---Event loop process message---check whether statck is empty or not--if empty--
push callback function --send results back to end clients.


Networking: Blocking Servers : http

use case is to read file

c1 asks 1 gb file

c1----request-----------Webserver---createthread---read file(long running process)
c2----request-----------Webserver---createthread---read file(long running process)
c3----request-----------Webserver---createthread---read file(long running process)
c4----request-----------Webserver---createthread---read file(long running process)
c5----request-----------Webserver---createthread---read file(long running process)
c6----request-----------Webserver---createthread---read file(long running process)
c7----request-----------Webserver---createthread---read file(long running process)
c8----request-----------Webserver---createthread---read file(long running process)
c9----request-----------Webserver---createthread---read file(long running process)
c10----request-----------Webserver---createthread---read file(long running process)

Webserver:
1.create thread
2.read operations :IO --BLOCKING IO operations
3.once done , remove threads

problems

1.dead lock
2.resource utilation
3.race conditions


Networking: NonBlocking Servers(async) : http

use case is to read file

c1 asks 1 gb file                                     os kernal

c1----request-----------Webserver---|      createthread---read file(long running process)
c2----request-----------Webserver---|     createthread---read file(long running process)
c3----request-----------Webserver---|      createthread---read file(long running process)
c4----request-----------Webserver---|     createthread---read file(long running process)
c5----request-----------Webserver---| --  createthread---read file(long running process)
c6----request-----------Webserver---|     createthread---read file(long running process)
c7----request-----------Webserver---|      createthread---read file(long running process)
c8----request-----------Webserver---|      createthread---read file(long running process)
c9----request-----------Webserver---|     createthread---read file(long running process)
c10----request-----------Webserver--|     createthread---read file(long running process)

///////////////////////////////////////////////////////////////////////////////////////////

Node is platform: it is not only runtime.

Node is collection of many compoents.

Javascript runtime:
Node has been built on google javascript runtime called "V8"

V8 has :
 stack
 heap

Lib :libuv

ibuv is a multi-platform support library with a focus on asynchronous I/O.


Node binding layer:

 it is low level c lib.

Node binding layer : high level

 it is javascript api layer.
///////////////////////////////////////////////////////////////////////////////////////////

Why node was created? What type of problems node is going to solve?


javascript is created only for manipulating documents==DOM programming.

Ryan Dahl who understand the power of js language, but language had limitions

js cant be used to build io applications =network application where we require high conncurrency.

Single thread, event driven, non blocking network application(http,tcp,udp) if you want to build,Who decided to build javascript based architecture to build non blocking "io/network application"
  That is brith of NODE.JS project.


Ryan added network related apis from "libuv" + javascript apis from js language


Node offers
Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
Asynchronous TCP and UDP sockets
Asynchronous DNS resolution
Asynchronous file and file system operations
File system events
ANSI escape code controlled TTY
IPC with socket sharing, using Unix domain sockets or named pipes (Windows)
Child processes
Thread pool
Signal handling
High resolution clock
Threading and synchronization primitives

/////////////////////////////////////////////////////////////////////////////////////////////

Node Programming:

1.Async programming and implementation

2.Node io programming

3.npm

4.web programming

5.Microservices Programming.



Async programming:


function sayHello() {
    console.log('hello');
}

sayHello() 

is the above code is async or not?
 No!.

how to know which is async?

1.the api(function) which you use should be part of libuv lib
refer doc:
common async api

1.timers
  settimeout,setinterval,setImmediate
2.node fs api (file system) : read and write
3.node networking apis : to write network applications
4.js apis
  Promise,async await
etc....

2.you must have callback function(handler function) 
   The function to be called by event loop once event is emitted by os.

callback function : function as parameter.

async api ====> {function as prop + high level async api binding}

                             "All api not async apis"


/////////////////////////////////////////////////////////////////////////////////////////////

Async implementation:

timers:
//async programming :timers

function hello() {
    console.log('hello')
}

hello();
//async

// setTimeout(function () {
//     console.log('i am delayed')
// }, 1000);

setTimeout(() => {
    console.log('i am delayed')
}, 1000);

const callback = function () {
    console.log('i am delayed 2')

}
setTimeout(callback, 3000);

hello()
console.log('something ...')
///////////////////////////////////////////////////////////////////////////////
// function connect(cb) {
//     //timer
//     // setTimeout(cb, 1000); 
//     setTimeout(() => {
//         cb();
//     }, 1000)
// }
// connect(() => {
//     console.log('HTTP server')
// })
//after time out , i want to return data
function connect(cb) {
    //timer
    // setTimeout(cb, 1000); 
    let fakeData = 'Web Server';

    setTimeout(() => {
        cb(fakeData);
    }, 1000)
    //setTimeout(cb, 1000, fakeData);
}
//connect(func)===>stack==>excution starts===setTimeout---|never creates--
//|register callback---move control to libuv| control is returned to main process
//js engine

//libuv---will schedule the job in os | thread is running---emit event(timer)--->
//libuv(event queue)----loop runs--check whether current stack is empty--if yes
//then push into stack==>frame is created==>result is returned to client
connect(message => {
    console.log(message)
})
/////////////////////////////////////////////////////////////////////////////////////////////

patterns to write async programming:
....................................

1.callback pattern

2.Promise pattern

3.promise + async and await


1.callback pattern:

it is core pattern, without this , we cant implement async programming.

//async programming patterns:


//callback based
//In any application, we need to handle errors.
//how to handle errors in async programming

// success,failure ===>resolve and reject

// const getUser = callback => {
//     let fakeData = {
//         id: 1,
//         name: 'admin'
//     }
//     setTimeout(callback, 1000, fakeData);
// }
// //get User 
// getUser(user => {
//     console.log(user)
// });


// biz logic with success and failure

const getUser = (resolve, reject) => {
    let fakeData = {
        id: 1,
        name: 'admin'
    }
   // let fakeData = null;//false
    //biz logic
    if (fakeData) {
        setTimeout(resolve, 1000, fakeData);
    } else {
        setTimeout(reject, 1000, { code: 500, message: 'User not found' });
    }
}
//get User 
getUser(user => console.log(user), err => console.log(err));

///////////////////////////////////////////////////////////////////////////////////////////

nested callabacks:

the out put of one callback , will become input to another callback ; callback nesting.

use case;

 getuser------data- success
    |		|
 failed		login -success  
   |             |
rejection    failed     |
              |	      show login page
              reject


//async programming patterns:


//callback based
//In any application, we need to handle errors.
//how to handle errors in async programming

// success,failure ===>resolve and reject

// const getUser = callback => {
//     let fakeData = {
//         id: 1,
//         name: 'admin'
//     }
//     setTimeout(callback, 1000, fakeData);
// }
// //get User 
// getUser(user => {
//     console.log(user)
// });


// biz logic with success and failure

const getUser = (resolve, reject) => {
    let fakeData = {
        id: 1,
        name: 'admin'
    }
    // let fakeData = null;//false
    //biz logic
    if (fakeData) {
        setTimeout(resolve, 1000, fakeData);
    } else {
        setTimeout(reject, 1000, { code: 500, message: 'User not found' });
    }
};

const login = (user, resolve, reject) => {
    //biz logic
    if (user.name === 'admin') {
        setTimeout(resolve, 1000, { code: 200, message: 'Login Success' });
    } else {
        setTimeout(reject, 1000, { code: 500, message: 'Login failed' });

    }
};

const showPage = (loginStatus, resolve, reject) => {
    //biz
    if (loginStatus.code === 200) {
        setTimeout(resolve, 1000, 'You are Administrator');
    } else {
        setTimeout(reject, 1000, 'You are not Administrator');
    }
}



//get User 
//getUser(user => console.log(user), err => console.log(err));

getUser(user => {
    //call login function with three parameters
    login(user, status => {
        showPage(status, isAdmin => {
            console.log(isAdmin)
        }, err => console.log(err));
    }, err => console.log(err));
}, err => console.log(err));
//////////////////////////////////////////////////////////////////////////////////////////

Callback Hell:
.............

look at the above function call, ask your self

Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

  "No" : This is what we call as "Callback hell"

Callback hell is not error, but way of writing async programming using nested callback.


fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

           "callback hell is other wise called as doom of pyrbid."



///////////////////////////////////////////////////////////////////////////////////////////

How to write better callback programming? or How to avoid callback hell?

Solution : One Design pattern is 


In 2005, JQUERY team started with working complex callback patterns, they found callback
hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "promise".


Promise is design pattern which hides complexity of callback patterns.

SInce Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

Because of popularty of this design among javascript developers, ECMA 6 Committee introduced
"promise design pattern in ES6 as Promise"

Promise Object is reference implementation of "promise design pattern".

Js has lot of built in objects

Object
Wrapper Objects: Number,String,Boolean
Math
Date
JSON --Parser Object
Promise

features of Promise Object:

1.Promise by deafult is Async. Which implements timer api with 0 ms .

2.Promise can be used with any async implementations.


Promise Implemenation / Promise Objects:
........................................

1. Create Promise Object from Promise contructor
        new Promise()
2. Create Promise object from factory apis
   ClassName.getInstance()===Object
	Promise.resolve() ==>Promise
        Promise.reject() ===>Promise


Promise object methods:
1.then - success
2.catch - errors
3.finally - clean up
4.resolve
5.reject
6.all
7.race
///////////////////////////////////////////////////////////////////////////////////////////

                   When to use factory api and when to use constructor 
				to create Promise Object



//Promises

//Create Promise Object using factory apis
//Promises are by default async
const { log } = console;

//resolve
function getSuccess() {
    //return promise Object
    return Promise.resolve('Success');//New Promise Object
}
log('start')
// let result = getSuccess();
// //to get output
// result.then(res => console.log(res));
//code : builder pattern or command chain pattern
//"hello".toLocaleLowerCase().toUpperCase().trim()
//getSuccess().then(res => console.log(res));

//if single variable , that are going to print, you need not declare that variable
//getSuccess().then(console.log);
getSuccess().then(log);

log('end');





const { log } = console;
const getUser = () => {
    let fakeData = {
        id: 1,
        name: 'admin'
    }
    // let fakeData = null;//false
    //biz logic
    if (fakeData) {
        // setTimeout(resolve, 1000, fakeData);
        return Promise.resolve(fakeData);
    } else {
        // setTimeout(reject, 1000, { code: 500, message: 'User not found' });
        return Promise.reject({ code: 500, message: 'User not found' });
    }
};

const login = user => {
    //biz logic
    if (user.name === 'admin') {
        // setTimeout(resolve, 1000, { code: 200, message: 'Login Success' });
        return Promise.resolve({ code: 200, message: 'Login Success' });

    } else {
        // setTimeout(reject, 1000, { code: 500, message: 'Login failed' });
        return Promise.reject({ code: 500, message: 'Login failed' });

    }
};

const showPage = loginStatus => {
    //biz
    if (loginStatus.code === 200) {
        //setTimeout(resolve, 1000, 'You are Administrator');
        return Promise.resolve('You are Administrator');

    } else {
        // setTimeout(reject, 1000, 'You are not Administrator');
        return Promise.reject('You are not Administrator');

    }
}
//
// getUser(user => {
//     //call login function with three parameters
//     login(user, status => {
//         showPage(status, isAdmin => {
//             console.log(isAdmin)
//         }, err => console.log(err));
//     }, err => console.log(err));
// }, err => console.log(err));

// getUser()
//     .then(user => {
//         return login(user) //returns promise
//     })
//     .then(status => {
//         return showPage(status) //returns Promise
//     })
//     .then(log)
//     .catch(log)
//     .finally(() => console.log('Program is terminted'))


getUser()
    .then(user => login(user))//returns promise
    .then(status => showPage(status)) //returns Promise
    .then(log)
    .catch(log)
    .finally(() => console.log('Program is terminted'))

////////////////////////////////////////////////////////////////////////////////////////////

Promise Constructor:

1. if you want to convert any callback based aync application


Use case 1 : i want to wrap timer with promise.
...............................................

//Promise constructor 

const { log } = console;

const getUser = () => {

    return new Promise((resolve, reject) => {
        //biz logic
        let fakeUser = {
            id: 1,
            name: 'admin'
        }
        if (fakeUser) {
            setTimeout(resolve, 1000, fakeUser);
        } else {
            setTimeout(reject, 1000, { code: 500, message: 'Error' })
        }

    });

}
getUser()
    .then(log)
    .catch(log)

//////////////////////////////////////////////////////////////////////////////////////////////

mock data 

src/data/todos.js

please refer this url and copy and paste into this file
https://jsonplaceholder.typicode.com/todos

src/services/todoservice.js
const TODOS = require('../data/todos');


class TodoService {
    constructor() {
    }
    //sync api
    // findAllTodo() {
    //     return TODOS;
    // }
    //async code : with callbacks
    // findAllTodo(callback) {
    //     setTimeout(callback, 1000, TODOS)
    // }

    //async code : with promise
    findAllTodo() {
        return new Promise((resolve, reject) => {
            //async
           //any legacy async api with callback
           setTimeout(resolve, 1000, TODOS)
        })
    }
}
module.exports = new TodoService();



src/todoapp.js
const { findAllTodo } = require('./services/TodoService');

const { log } = console;

function fetchAllTodos() {

    //sync call
    //findAllTodo().forEach(log)
    //async call :using callbacks
    // findAllTodo(todos => {
    //     todos.forEach(log);
    // });
    //async call : using Promises
    findAllTodo().then(todos => {
        todos.forEach(log);
    });
}

//call
fetchAllTodos();

/////////////////////////////////////////////////////////////////////////////////////////

Promise Hell:
............

How to solve promise?











