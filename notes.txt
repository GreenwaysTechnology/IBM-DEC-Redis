
ES 6 - Concepts and implementation

Node js

Microservices using Node js :Moleculer

/////////////////////////////////////////////////////////////////////////////////////

Lab ;

1.node.js
2.vs code : editor

/////////////////////////////////////////////////////////////////////////////////////////

open vs code : code  .

///////////////////////////////////////////////////////////////////////////////////////////

ES 6 ;

What is es 6?

ecma script 6 
es 6 is version of javascript.


javascript is programming language.

javascript is object based,functional style,event driven pl.

javascript follows 3 major programming paradigms. =hybrid.

javascript is invented for web docment manupulation : DOM Programming. 
  javascript web script.

now a days javascript is every where , after 2008, after node was introduced

 -web document maniulation : UI programming - jquery,angular,react,vue

 -web application  - node js -  express,loopback,.....

 -distributed application(microservices) - node js -molecular....

javascript has versions and javascript standarized by Committe "ECMA international committe".

js---1.0 es 1.0

es 3 -1999

es 4 -2007

es 5 -2008

es 6 -2012 --->2015

es 7,es 8.....

////////////////////////////////////////////////////////////////////////////////////////////

js language


js is dynamic typed pl. data types are under stood in the runtime.


es 5/ es 6
1.language fundamentals
   -variables and literals
   -operators
   -loops,
   -constrol structure
2.functions
   fp programming
3.object based programming
   objects
4.dom programming
 
5.networking programming


//how to declare variables
/**
 * ways 
 * using var keyword -> es 5
 * using let and const keywords - es 6
 *   let and const is replacer for var
 *  if you are building application based on es 6 always
 * recommended to let / const
 *  * using this keywords
 * 
 * java code is running on jvm(runtime)
 *   -sun,oracle,openjdk,zuel,HP,ibm
 * javascript code is running on javascript runtime
 *  -classified into two category
 *   -embeded : inside another software:(browser)
 *   -standalone : node js
 * 
 * vendors:
 *   -chrome : v8
 *   -firefox : spidermonkey
 *   -opera : operaEngine
 *  - ie - chakara
 * 
 * nodejs
 *  -v8
 * 
 * Version combability:
 *  jvm -5 --if you run java 8 will work -? wont
 * 
 *  js engine certified by es 5----will support only es 5 features
 *  suppose not means---y cant
 *    convert es 6 code into es 6 : transipling /compilation : converting es 6 code into
 *   es 5 code and run.
 * 
 * should i do this every time, yes!!! -best practice
 * 
 * good thing, modern browsers  and node supports es 6 directly.
 * 
 */
//variable declarion
//var is keyword 
//firstName is variable
//"Subramanian" : literal
/**
 * types of literal
 *  string
 *  number
 *  boolean
 *  undefined
 *  NaN
 *  infinity
 *  null
 * function
 * object 
 */

//string : " " ,'' ,``
//var firstName = "Subramanian";
let firstName = "Subramanain";

//var lastName = 'Murugan';
let lastName = "Murugan";

console.log("firstName " + firstName);
console.log("firstName ", firstName);

//es 6 template literal : ``
console.log(`firstName ${firstName}  lastName ${lastName}`);

//backtick for multi line string literal :
// var title = 'IBM digital'
let title = 'IBM digital'

//es 5 style
let htmlDoc = "<html>" +
    "<head>" +
    "<title>" + title + "</title>"
"<body>" +
    "</body></html>";
console.log(htmlDoc)
//es 6 style
let htmlDocNew = `
    <html>
    <head>
       <title>${title}</title>
    </head>
    <body>

    </body>
    </html>
`;
console.log(htmlDocNew)
///////////////////////////////////////////////////////////////////////////////
//undefined; variable is declarated but no valid values, js initalizes undefined
//undefined itself is value only.

//undefined
let covid19todaysCount;
console.log(`covid19todaysCount ${covid19todaysCount}`)

//////////////////////////////////////////////////////////////////////////////////
//numbers : number,NaN,infinity

//number : 64 bit : double
let totalDischarged = 12300;
console.log(`totalDischarged ${totalDischarged}`)

//computation
let totalPatientsInHosiptal = 55000 - totalDischarged;
console.log(`totalPatientsInHosiptal ${totalPatientsInHosiptal}`)

//comuputational error : NaN : not a number: error code ,thrown by js when something 
//went wrong duration numerical operations.

//NaN and undefined
let qty; //undefined
let unitprice = 100;
let totalValue = qty * unitprice; // undefined * number==>error-NaN
console.log(`Total Value ${totalValue}`)

//NaN and type conversion
//string to number conversion
//implicit and explicit
//conversion
// let stockValue = "1000" // string but value is number
// let totalStockValue = stockValue * 100; //conversion happens first then computation: implicit
// console.log(`totalStockValue ${totalStockValue}`)

let stockValue = "$1000" // string but value is number
let totalStockValue = stockValue * 100; //conversion failed,throwing NaN
console.log(`totalStockValue ${totalStockValue}`)

//inifity
let avgDeathRate = 55000 / 0;
console.log(`avgDeathRate ${avgDeathRate}`)
///////////////////////////////////////////////////////////////////////////////////
//booleans
let isActive = true;
console.log(`Active ${isActive}`)
///////////////////////////////////////////////////////////////////////////////////
//Advanced booleans: which is true and which is false

/**
 * in js every thing is true except the following values
 * 
 *  1.boolean false
 *  2."",''(empty string)
 *  3.0 
 *  4.undefined
 *  5.NaN
 *  6.null
 * 
 */

let message = "hi";
//if(boolean);
if (message) {
    console.log("ok!")
} else {
    console.log("not ok!")
}
let count = 0;
if (count) {
    console.log("Count ok!")
} else {
    console.log("Count not ok!")
}
//////////////////////////////////////////////////////////////////////////////
//operators
//comparsional operator : == , === != , !==

let a = "10"; //string
let b = 10; //number

let result1 = a == b; // string == number : wrong comparasion
let result2 = a === b; //right comparsion
console.log(`${result1} ${result2} `);

//best pratice : when ever you compare use always : ===
/////////////////////////////////////////////////////////////////////////
// ? : tenary : to replace if conditions

message ? console.log('message ok') : console.log('message not oke');
(a === b) ? console.log('a and b ar equal') : console.log('a and b not equal');
///////////////////////////////////////////////////////////////////////////////////
// || && operators

let isEnabled = true;
let status = isEnabled || isActive;
console.log(status ? 'success' : 'failure');

let init = 12;
//if first operand(init) is truthy, the result would be first
// else result would be second one
//&& is opposit formula to or so you can test yourself
let start = init || 10;
console.log(`Start ${start}`)

///////////////////////////////////////////////////////////////////////////////
//typeof operator ; returns the type of variable
console.log(typeof "hello")
console.log(typeof message)
//number,infinity,NaN
console.log(typeof totalValue)
console.log(typeof avgDeathRate)
/////////////////////////////////////////////////////////////////////////////////

//other operators : new,instance of , for...in,[],.

///////////


//const 
//let and const both are same

let firstName = 'subramanian';
console.log(`FirstName ${firstName}`);
//re initalize
firstName = 'Ram'
console.log(`FirstName ${firstName}`);

//const never allows to reinitalize the variables
const pi = 3.14
console.log(`PI ${pi}`);
pi = 89.90;


////////////////////////////////////////////////////////////////////////////////////////////

functional programming:

function is logical representation of organization of code in js.

function in es6 and es 5:


//functions
//declaration
/**
 * normal delcaration
 * literal declaration
 */
//function declaration

function sayHello() {
    //function body
    console.log('hello');
}
//invoke function
sayHello();

//some logic inside function
function calculator() {
    let a = 10;
    let b = 90;
    let result = a + b;
    console.log(`Result ${result}`)
}
calculator();
//parameters and args
//a and b are args
//es 6 has feature called "default args"
function add(a = 1, b = 1) {
    let result = a + b;
    console.log(`Result ${result}`)
}
//10,10 are parameters
add(10, 10)
add();//undefined,undefined

//i want to pass more parameters , i dont this in advance
//Rest operator
function logger(...logs) {
    // console.log(arguments)
    console.log(logs)
}
logger('msapp', 'warning')
logger('msapp')
logger('msapp', 'y', 'x', 'err')
//////////////////////////////////////////////////////////////////////////
// function multiply() {
//     return 10 * 10;

// }
function multiply(a = 1, b = 1) {
    return a * b;

}
console.log(multiply(34, 89))

function isValid() {
    return; // undefined==false
}
isValid() ? console.log('Valid') : console.log('InValid')




//functtion literal
/**
 * in js function is value.
 * since it is value can be assigned to variable.
 * since it is value can be passed as parameter to another function
 * since it is value can be returned from another function.
 */
//function declaration using literal
//let is keyword
//a is variable
//10 is numeric literal
let a = 10;

//function is assigned into a variable , that variable can be used to invoke that
//function
let add = function (a = 1, b = 1) {
    let result = a + b;
    console.log(result);
}
add();

let multiply = function (a = 1, b = 1) {
    return a * b;
}
console.log(multiply(12,34))


////////////////////////////////////////////////////////////////////////////////////////////

es 6 representation of function: arrow function

//Arrow function : replacment of es 5 function literals


// pattern 1: simple arrow

// let hello = function () {
//     console.log('hello');
// }
let hello = () => {
    //function body
    console.log('hello');
}
hello();
//pattern 2: only one line of body,remove {}
let hai = () => console.log('hai');
hai();
//pattern 3: parameters and args : multi parameter with default args
let add = (a = 1, b = 2) => {
    let res = a + b;
    console.log(res);
}
add(39, 78)
//Pattern 4;single parameter without default args,drop ()
let greet = message => console.log(message);
greet('Hello')
//pattern 4: return values
let getValue = () => {
    return 100;
}
console.log(getValue());
//pattern 5: only return, no more body : remove {} and return statement
let getName = () => "Subramanian";
console.log(getName());
////pattern 6: args and return: single arg no default args, return the same
let getStatus = status => status;
console.log(getStatus(true))

//////////////////////////////////////////////////////////////////////////////////////////

function as parameter and function returning

//function as parameter: function can be passed into another function as parameter
//because function is just literal.

//a =10
//a = x;
function add(a, b) {
    return a + b;
}
//values directly
console.log(add(10, 90))
//via variables
let x = 10;
let y = 90;
console.log(add(x, y))



//function parameters
//connect is just variable, can hold any value(literal)
//connect = webServerConnect =function () {
//     console.log('webServer')
// };
function connectServer(server, connect) {
    const statuscode = connect(server);
    console.log(`status ${statuscode}`)
}

//via variables
let webServerConnect = function (server) {
    console.log(server)
    return `SUCCESS 200`
};
connectServer('HTTP Server is Running', webServerConnect);
//anonmous function : function with out name
connectServer('Database Server is Running', function (server) {
    console.log(server)
    return `SUCCESS 200`
});

//function as parameter: function can be passed into another function as parameter
//because function is just literal.

// function connectServer(server, connect) {
//     const statuscode = connect(server);
//     console.log(`status ${statuscode}`)
// }

// //via variables
// let webServerConnect = function (server) {
//     console.log(server)
//     return `SUCCESS 200`
// };
// connectServer('HTTP Server is Running', webServerConnect);
// //anonmous function : function with out name
// connectServer('Database Server is Running', function (server) {
//     console.log(server)
//     return `SUCCESS 200`
// });

const connectServer = (server, connect) => {
    const statuscode = connect(server)
    console.log(`status ${statuscode}`)
}

let webServerConnect = server => {
    console.log(server)
    return '200 SUCCESS'
};
connectServer('HttpServer', webServerConnect);

connectServer('SQL server', server => {
    console.log(server)
    return '200 SUCCESS'

});


//how to return function from another function

function counter() {
    console.log('counter')
    //inner function
    // return function increment() {
    //     console.log('increment')
    // }

    // //anonmous function
    return function (value) {
        console.log('increment')
        return value;
    }
    // //increment()
}
//inc is pointer to function:
// const inc = counter();
// console.log(inc(100));
console.log(counter()(1222))

//arrow version
// const counterNew = () => {
//     console.log('counter')
//     return value => `increment ${value}`;
// }
// const counterNew = () => {
//     return value => `increment ${value}`;
// }
const counterNew = () => value => `increment ${value}`;

// const inc1 = counterNew();
// console.log(inc1(100));
console.log(counterNew()(9000))
/////////////////////////////////////////////////////////////////////////////////

//curry function:function returns another function which returns another function and so...on

// function makeCake(milk) {
//     return function (cream) {
//         return function (sugar) {
//             return function (color) {
//                 return `${milk} ${cream} ${sugar} ${color}`
//             }
//         }
//     }
// }

// const makeCake = milk => {
//     return cream => {
//         return sugar => {
//             return color => {
//                 return `${milk} ${cream} ${sugar} ${color}`
//             }
//         }
//     }
// }
const makeCake = milk => cream => sugar => color => `${milk} ${cream} ${sugar} ${color}`

console.log(makeCake('cow milk')('cho cream')('brown sugar')('red'))




//closure : if outer is terminated but still inner will access outter function variables
//and args.

function counter(seedvalue = 1) {

    //outer function variable
    let count = seedvalue;
    return function () {
        //access outter function variable: closure
        return count++;
    }
}
let inc = counter(5)
console.log(inc());
console.log(inc());
console.log(inc());
console.log(inc());
console.log(inc());
console.log(inc());
console.log(inc());
console.log(inc());
console.log(inc());
console.log(inc());

///////////////////////////////////////////////////////////////////////////////////////

Object based concepts:


Object : memory => object state,object identity,object behaviour.

How to create Object?

Object template =class =>js class free object based language.

Two ways of creating object

1.constructor pattern
   calling constructors
    ->function
    -es 6 class
2.literal pattern




//object based programming

//object template : function

function Employee() {
    //state instance variable
    this.id = 1;
    this.name = 'subramanian';
    //methods
    this.calculateSalary = function () {
        return 1000;
    }
}
//object creation
//emp is just variable, new is operator,Employee() is constructor call
let emp = new Employee();
console.log(`id ${emp.id} Name ${emp.name} salary ${emp.calculateSalary()} `)

// ES 6 CLASSES
class Customer {
    id = 1;
    name = 'subramanian';
    //methods
    calculateInvoice() {
        return 1000;
    }
}

let cust = new Customer();
console.log(`id ${cust.id} Name ${cust.name} Invoice ${cust.calculateInvoice()} `)


//////////////////////////////////////////////////////////////////////////////////////////////
state initalization:
...................
1.hard coded way
2.after object creation
3.constructor parameters



// state : update

function Employee(id = 1, name = 'subramanian') {
    //state instance variable
    this.id = id //1;
    this.name = name //'subramanian';
    //methods
    this.calculateSalary = function () {
        return 1000;
    }
}
//object creation
//emp is just variable, new is operator,Employee() is constructor call
let emp = new Employee(45, 'john');

console.log(`id ${emp.id} Name ${emp.name} salary ${emp.calculateSalary()} `)

//after object creation
emp.name = 'ram'

console.log(`id ${emp.id} Name ${emp.name} salary ${emp.calculateSalary()} `)

// ES 6 CLASSES
class Customer {

    constructor(id = 1, name = 'subramanian') {
        this.id = id;//1;
        this.name = name;//'subramanian';
    }
    //methods
    calculateInvoice() {
        return 1000;
    }
}

let cust = new Customer(90, 'James');
console.log(`id ${cust.id} Name ${cust.name} Invoice ${cust.calculateInvoice()} `)

cust.name = 'ram';
console.log(`id ${cust.id} Name ${cust.name} Invoice ${cust.calculateInvoice()} `)
///////////////////////////////////////////////////////////////////////////////////////////

literal pattern:

//literal pattern

// const emp = {
//     id: 1,
//     name: 'subramanian',
//     calculateSalary: function () {
//         return 1000;
//     }
// }

// const emp = {
//     id: 1,
//     name: 'subramanian',
//     calculateSalary: () => 1000
// }
const emp = {
    id: 1,
    name: 'subramanian',
    calculateSalary() {
        return 1000
    }
}

console.log(`id ${emp.id} Name ${emp.name} salary ${emp.calculateSalary()} `)
///////////////////////////////////////////////////////////////////////////////////////////

Hierachy : object relationship : has-a , is-a(inheritance)



//inhertiance 
//has-a composition

class Customer {
    constructor(id = 1, name = 'Subrammanian') {
        this.id = id;
        this.name = name;
    }
}

class Account {

    constructor(accountNo, name, customer = new Customer()) {
        this.accountNo = accountNo;
        this.name = name;
        //has-a relationship
        this.customer = customer;

        console.log('account')
    }
    //method
    withdraw() {
        return 100;
    }
}
class SavingsAccount extends Account {
    constructor(accountNo, name) {
        super(accountNo, name);
        console.log('savings account!')
    }
    withdraw() {
        return 400 * super.withdraw();
    }
}
let sb = new SavingsAccount(1, 'Savings Account');
console.log(sb.accountNo, sb.name, sb.customer.id, sb.customer.name)
console.log(sb.withdraw())


//////////////////////////////////////////////////////////////////////////////////////

Object destrucing:
.................

//De Structure : breaking the object keys and make it simple

// function getEmployee(employee) {
//     console.log(`Id ${employee.id}`)
//     console.log(`Name ${employee.name}`)
//     console.log(`City ${employee.city}`)
//     console.log(`State ${employee.state}`)
// }

// function getEmployee(employee) {
//     //destructure
//     const { id, name, city, state } = employee;
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`City ${city}`)
//     console.log(`State ${state}`)
// }
// function getEmployee({ id, name, city, state, department: { depname, location } }) {
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`department ${depname} ${location}`)
//     console.log(`City ${city}`)
//     console.log(`State ${state}`)
// }
const getEmployee = ({ id, name, city, state, department: { depname, location } }) => {
    console.log(`Id ${id}`)
    console.log(`Name ${name}`)
    console.log(`department ${depname} ${location}`)
    console.log(`City ${city}`)
    console.log(`State ${state}`)
}
getEmployee({
    id: 1,
    name: 'subramanian',
    city: 'coimbatore',
    state: 'tamil nadu',
    department: {
        depname: 'Training',
        location: 'Banaglore'
    }
});
////////////////////////////////////////////////////////////////////////////////

const getCustomer = () => ({
    id: 1000,
    name: 'James',
    city: 'coimbatore',
    state: 'tamil nadu'
})


console.log(getCustomer())

//how to configure object property values dynamically

// const getVisitor = (id, name, city, state) => ({
//     id: id,
//     name: name,
//     city: city,
//     state: state
// })

//how to configure object property values dynamically

//objectKey: localvariable(funciton arg )
//if key and local variable is same :
// id:id,name:name => make it one , id,name
const getVisitor = (id, name, city, state) => ({
    id,
    name,
    city,
    state,
})


console.log(getVisitor(1000, 'John', 'Chennai', 'TN'))

/////////////////////////////////////////////////////////////////////////////////////////////
Modularity:
..........

code sharing

javascript language did not introduce file to file linking , file to file code sharing.

java:
 
folders and files

packages, import

package com.ibm.digital ===>com/ibm/digital/HomeService.java

Modularity started becoming important late 2000.

Js community wanted file and code sharing methods, they are introduced design patterns

module design patterns

1.NAMES PACE --- first design pattern --2001
2.AMD -Aync module design pattern -2002
3.CJS -common js design pattern -2006 :
   point : even today this design pattern is used
           node js implements this design pattern by default.

4.es6 modules -  2012--2015 
5.system --2016
6.umd --2017

/////////////////////////////////////////////////////////////////////////////////////////////

cjs design pattern


code sharing among files;

what is code?

code could be any thing(variables =can hold any literal,function,class)

how to link files?

cjs provides some keywords

for sharing and linking

sharing :
 exports
 module.exports

file linking
code          require('folder and filename') function
 |                          |
returnvalue                location 


src
  -mylib.js
   console.log('mylib')

 -index.js
	require('./mylib')


code sharing:
primitive : string,number,boolean

exports

src/index.js

//require returns code from mylib as object
//
// const result = require('./mylib')
// console.log(result);

// console.log(result.name);
// console.log(result.id)
// console.log(result.isActive)
// console.log(result.calculateScore())

//object destructuring

const { id, name, isActive, calculateScore } = require('./mylib')

console.log(name);
console.log(id)
console.log(isActive)
console.log(calculateScore())

src/mylib.js


//code sharing

exports.id = 1
exports.name = 'Subramanian';
exports.isActive = true;
exports.calculateScore = function () {
    return 10;
}

/////////////////////////////////////////////////////////////////////////////////////

Object augmentation:
...................

Objects are just simple datastructure ; map.

map -- key ;value

key:value
property:literal 

since object is ds, you can do some operations

add,delete,update,iterate

//Object augmentation
//add,remove,update,iterate object 

//empty object
let product = {};

//add new property
product.id = 10;
product.price = 900;
product.name = 'think pad'
product.qty = 90;

//update : js engine looks whether property exits or not, if exit update,else add
product.price = 870;

//remove property
delete product.qty

//iterate
//operator to access object properties 
// . operator : used only for known object property
// [] operator : used for accessing object property dynamically, which is unknown
for (const key in product) {
    console.log(key, product[key]);
}


console.log(product)
////////////////////////////////////////////////////////////////////////////////////////////

node has in built cjs loader.

browser has no any third loader(cjs,es6...)


//////////////////////////////////////////////////////////////////////////////////////////////

module.exports

1.which exports code as it is.
   Which does not add inside any object.
 if you return a variable, the variable will retuned as it.

2.per file only one module.exports allowed


src/data/customer-data.js


const CUSTOMERS = [{ id: 1, name: 'A1' },{ id: 2, name: 'A2' }]

module.exports = CUSTOMERS;

src/services/customerservice.js

/**
 * 
 * function require(fileName){
 * 
 * class CustomerService {
    constructor() {
        console.log('constructor is called')
    }
    findAll() {
        return [{ id: 1, name: 'A' }]
    }
}
    return CustomerService;
 * 
 * }
 */
const CUSTOMERS = require('../data/customer-data');

class CustomerService {
    constructor() {
        console.log('constructor is called')
    }
    findAll() {
        return CUSTOMERS;
    }
}
module.exports = CustomerService;

src/index.js
const { id, name, isActive, calculateScore } = require('./mylib')
const CustomerService = require('./services/CustomerService')


console.log(name);
console.log(id)
console.log(isActive)
console.log(calculateScore())
let service = new CustomerService();
console.log(service.findAll())
/////////////////////////////////////////////////////////////////////////////////////////////

What is node.js

Node is javascript platform and runtime to run javascript programms.

Js language features:

javascript is async programming language.

concurrency
  -doing multiple things at the same time.
threading : sub process
if you run many task at the same time-multi threading.

Does js support multithreading?
 No!--js single thread engine.

how to implement in concurrency in js?

runtime architecture

what is runtime ?
  program in excution => process.

program types:

1.passive program  
  the program which is not in main memory.
  the program which is main memory but not accessed by cpu.

2.active program

 the program which is in main memory accessed by cpu
 active program is other wise called process.

Point:

Any thing(program) inside ram will have structure.

Process structure====>runtime structure===> js engine structure==> Node structure

heap 
  dynamic memory segment used to allocate memory on fly for the running programms
stack
  dynamic memory segment used to allocate memory for "methods/functions"
program data
 -common passive data for running process
//////////////////////////////////////////////////////////////////////////////////////////////

stack:

function  sayHello(){
 ///logic 
  let name ='subramanian'
}

//Objective of function call
//to perform task , who will perform task=>cup
//cup will communicate always RAM

function call means , moving function to ram,Any thing(program) inside ram will have structure.
i need function structure, who will create/allocate function structure ?
       "stack"
sayHello();

How many frames can be run at the same time?

in general , you can run only one active frame.

can i run/create multiple frames?

Yes!....

what is frame?
  -thread

can i run multiple frames(threads) in javascript?

 No,

then how i can achive concurrency.

--->Worker-thread Model/
--->Event--Loop architecture/
--->Reactor Model/
/////////////////////////////////////////////////////////////////////////////////////

Sync Programming : single frame architecture

only one frame can be executed
while running one frame, other functions has to wait => "Blocking"

//blocking /sync programming

function sayHello() {
    console.log('hello');
}
function add(a = 1, b = 2) {
    let c = a + b;
    console.log(c);
}
//invoke functions
//sayhello---stack---frame is created---running|once done--frame is removed 
sayHello() 
//add--stack--frame is created---running|once done--frame is removed
add(10, 10);
//////////////////////////////////////////////////////////////////////////////////////////

What is the problems single frame arch?

 -frame takes longer time to complete, other programs will wait: blocking

frames should block other programs : Non blocking

 Async Progamming ;concurrency architecture

Async architecture is designed based on one design pattern "Reactor Design Pattern"

Worker-thread Model : dont create frame(thread) at the process level

funcall()-------stack---|---------------os kernal--thread is running--


how data is returned to end users once the task is completed?

  "Event driven architecture"

  Signal : completed,connected,closed......


Event Queue(Task Queue)
  It is data structure which has completed job references in the form of functions
    - callback functions : handler function :==>will have data to be retuned to end user


Event loop
    It is program which keeps on checking the queue whether any message should be
   processed : for what , in order to send results back to clients.


funcall()-------stack---|---------------os kernal--thread is running--Completed-->push into
 Event Queue---Event loop process message---check whether statck is empty or not--if empty--
push callback function --send results back to end clients.


Networking: Blocking Servers : http

use case is to read file

c1 asks 1 gb file

c1----request-----------Webserver---createthread---read file(long running process)
c2----request-----------Webserver---createthread---read file(long running process)
c3----request-----------Webserver---createthread---read file(long running process)
c4----request-----------Webserver---createthread---read file(long running process)
c5----request-----------Webserver---createthread---read file(long running process)
c6----request-----------Webserver---createthread---read file(long running process)
c7----request-----------Webserver---createthread---read file(long running process)
c8----request-----------Webserver---createthread---read file(long running process)
c9----request-----------Webserver---createthread---read file(long running process)
c10----request-----------Webserver---createthread---read file(long running process)

Webserver:
1.create thread
2.read operations :IO --BLOCKING IO operations
3.once done , remove threads

problems

1.dead lock
2.resource utilation
3.race conditions


Networking: NonBlocking Servers(async) : http

use case is to read file

c1 asks 1 gb file                                     os kernal

c1----request-----------Webserver---|      createthread---read file(long running process)
c2----request-----------Webserver---|     createthread---read file(long running process)
c3----request-----------Webserver---|      createthread---read file(long running process)
c4----request-----------Webserver---|     createthread---read file(long running process)
c5----request-----------Webserver---| --  createthread---read file(long running process)
c6----request-----------Webserver---|     createthread---read file(long running process)
c7----request-----------Webserver---|      createthread---read file(long running process)
c8----request-----------Webserver---|      createthread---read file(long running process)
c9----request-----------Webserver---|     createthread---read file(long running process)
c10----request-----------Webserver--|     createthread---read file(long running process)

///////////////////////////////////////////////////////////////////////////////////////////

Node is platform: it is not only runtime.

Node is collection of many compoents.

Javascript runtime:
Node has been built on google javascript runtime called "V8"

V8 has :
 stack
 heap

Lib :libuv

ibuv is a multi-platform support library with a focus on asynchronous I/O.


Node binding layer:

 it is low level c lib.

Node binding layer : high level

 it is javascript api layer.
///////////////////////////////////////////////////////////////////////////////////////////

Why node was created? What type of problems node is going to solve?


javascript is created only for manipulating documents==DOM programming.

Ryan Dahl who understand the power of js language, but language had limitions

js cant be used to build io applications =network application where we require high conncurrency.

Single thread, event driven, non blocking network application(http,tcp,udp) if you want to build,Who decided to build javascript based architecture to build non blocking "io/network application"
  That is brith of NODE.JS project.


Ryan added network related apis from "libuv" + javascript apis from js language


Node offers
Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
Asynchronous TCP and UDP sockets
Asynchronous DNS resolution
Asynchronous file and file system operations
File system events
ANSI escape code controlled TTY
IPC with socket sharing, using Unix domain sockets or named pipes (Windows)
Child processes
Thread pool
Signal handling
High resolution clock
Threading and synchronization primitives

/////////////////////////////////////////////////////////////////////////////////////////////

Node Programming:

1.Async programming and implementation

2.Node io programming

3.npm

4.web programming

5.Microservices Programming.



Async programming:


function sayHello() {
    console.log('hello');
}

sayHello() 

is the above code is async or not?
 No!.

how to know which is async?

1.the api(function) which you use should be part of libuv lib
refer doc:
common async api

1.timers
  settimeout,setinterval,setImmediate
2.node fs api (file system) : read and write
3.node networking apis : to write network applications
4.js apis
  Promise,async await
etc....

2.you must have callback function(handler function) 
   The function to be called by event loop once event is emitted by os.

callback function : function as parameter.

async api ====> {function as prop + high level async api binding}

                             "All api not async apis"


/////////////////////////////////////////////////////////////////////////////////////////////

Async implementation:

timers:
//async programming :timers

function hello() {
    console.log('hello')
}

hello();
//async

// setTimeout(function () {
//     console.log('i am delayed')
// }, 1000);

setTimeout(() => {
    console.log('i am delayed')
}, 1000);

const callback = function () {
    console.log('i am delayed 2')

}
setTimeout(callback, 3000);

hello()
console.log('something ...')
///////////////////////////////////////////////////////////////////////////////
// function connect(cb) {
//     //timer
//     // setTimeout(cb, 1000); 
//     setTimeout(() => {
//         cb();
//     }, 1000)
// }
// connect(() => {
//     console.log('HTTP server')
// })
//after time out , i want to return data
function connect(cb) {
    //timer
    // setTimeout(cb, 1000); 
    let fakeData = 'Web Server';

    setTimeout(() => {
        cb(fakeData);
    }, 1000)
    //setTimeout(cb, 1000, fakeData);
}
//connect(func)===>stack==>excution starts===setTimeout---|never creates--
//|register callback---move control to libuv| control is returned to main process
//js engine

//libuv---will schedule the job in os | thread is running---emit event(timer)--->
//libuv(event queue)----loop runs--check whether current stack is empty--if yes
//then push into stack==>frame is created==>result is returned to client
connect(message => {
    console.log(message)
})
/////////////////////////////////////////////////////////////////////////////////////////////

patterns to write async programming:
....................................

1.callback pattern

2.Promise pattern

3.promise + async and await


1.callback pattern:

it is core pattern, without this , we cant implement async programming.

//async programming patterns:


//callback based
//In any application, we need to handle errors.
//how to handle errors in async programming

// success,failure ===>resolve and reject

// const getUser = callback => {
//     let fakeData = {
//         id: 1,
//         name: 'admin'
//     }
//     setTimeout(callback, 1000, fakeData);
// }
// //get User 
// getUser(user => {
//     console.log(user)
// });


// biz logic with success and failure

const getUser = (resolve, reject) => {
    let fakeData = {
        id: 1,
        name: 'admin'
    }
   // let fakeData = null;//false
    //biz logic
    if (fakeData) {
        setTimeout(resolve, 1000, fakeData);
    } else {
        setTimeout(reject, 1000, { code: 500, message: 'User not found' });
    }
}
//get User 
getUser(user => console.log(user), err => console.log(err));

///////////////////////////////////////////////////////////////////////////////////////////

nested callabacks:

the out put of one callback , will become input to another callback ; callback nesting.

use case;

 getuser------data- success
    |		|
 failed		login -success  
   |             |
rejection    failed     |
              |	      show login page
              reject


//async programming patterns:


//callback based
//In any application, we need to handle errors.
//how to handle errors in async programming

// success,failure ===>resolve and reject

// const getUser = callback => {
//     let fakeData = {
//         id: 1,
//         name: 'admin'
//     }
//     setTimeout(callback, 1000, fakeData);
// }
// //get User 
// getUser(user => {
//     console.log(user)
// });


// biz logic with success and failure

const getUser = (resolve, reject) => {
    let fakeData = {
        id: 1,
        name: 'admin'
    }
    // let fakeData = null;//false
    //biz logic
    if (fakeData) {
        setTimeout(resolve, 1000, fakeData);
    } else {
        setTimeout(reject, 1000, { code: 500, message: 'User not found' });
    }
};

const login = (user, resolve, reject) => {
    //biz logic
    if (user.name === 'admin') {
        setTimeout(resolve, 1000, { code: 200, message: 'Login Success' });
    } else {
        setTimeout(reject, 1000, { code: 500, message: 'Login failed' });

    }
};

const showPage = (loginStatus, resolve, reject) => {
    //biz
    if (loginStatus.code === 200) {
        setTimeout(resolve, 1000, 'You are Administrator');
    } else {
        setTimeout(reject, 1000, 'You are not Administrator');
    }
}



//get User 
//getUser(user => console.log(user), err => console.log(err));

getUser(user => {
    //call login function with three parameters
    login(user, status => {
        showPage(status, isAdmin => {
            console.log(isAdmin)
        }, err => console.log(err));
    }, err => console.log(err));
}, err => console.log(err));
//////////////////////////////////////////////////////////////////////////////////////////

Callback Hell:
.............

look at the above function call, ask your self

Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

  "No" : This is what we call as "Callback hell"

Callback hell is not error, but way of writing async programming using nested callback.


fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

           "callback hell is other wise called as doom of pyrbid."



///////////////////////////////////////////////////////////////////////////////////////////

How to write better callback programming? or How to avoid callback hell?

Solution : One Design pattern is 


In 2005, JQUERY team started with working complex callback patterns, they found callback
hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "promise".


Promise is design pattern which hides complexity of callback patterns.

SInce Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

Because of popularty of this design among javascript developers, ECMA 6 Committee introduced
"promise design pattern in ES6 as Promise"

Promise Object is reference implementation of "promise design pattern".

Js has lot of built in objects

Object
Wrapper Objects: Number,String,Boolean
Math
Date
JSON --Parser Object
Promise

features of Promise Object:

1.Promise by deafult is Async. Which implements timer api with 0 ms .

2.Promise can be used with any async implementations.


Promise Implemenation / Promise Objects:
........................................

1. Create Promise Object from Promise contructor
        new Promise()
2. Create Promise object from factory apis
   ClassName.getInstance()===Object
	Promise.resolve() ==>Promise
        Promise.reject() ===>Promise


Promise object methods:
1.then - success
2.catch - errors
3.finally - clean up
4.resolve
5.reject
6.all
7.race
///////////////////////////////////////////////////////////////////////////////////////////

                   When to use factory api and when to use constructor 
				to create Promise Object



//Promises

//Create Promise Object using factory apis
//Promises are by default async
const { log } = console;

//resolve
function getSuccess() {
    //return promise Object
    return Promise.resolve('Success');//New Promise Object
}
log('start')
// let result = getSuccess();
// //to get output
// result.then(res => console.log(res));
//code : builder pattern or command chain pattern
//"hello".toLocaleLowerCase().toUpperCase().trim()
//getSuccess().then(res => console.log(res));

//if single variable , that are going to print, you need not declare that variable
//getSuccess().then(console.log);
getSuccess().then(log);

log('end');





const { log } = console;
const getUser = () => {
    let fakeData = {
        id: 1,
        name: 'admin'
    }
    // let fakeData = null;//false
    //biz logic
    if (fakeData) {
        // setTimeout(resolve, 1000, fakeData);
        return Promise.resolve(fakeData);
    } else {
        // setTimeout(reject, 1000, { code: 500, message: 'User not found' });
        return Promise.reject({ code: 500, message: 'User not found' });
    }
};

const login = user => {
    //biz logic
    if (user.name === 'admin') {
        // setTimeout(resolve, 1000, { code: 200, message: 'Login Success' });
        return Promise.resolve({ code: 200, message: 'Login Success' });

    } else {
        // setTimeout(reject, 1000, { code: 500, message: 'Login failed' });
        return Promise.reject({ code: 500, message: 'Login failed' });

    }
};

const showPage = loginStatus => {
    //biz
    if (loginStatus.code === 200) {
        //setTimeout(resolve, 1000, 'You are Administrator');
        return Promise.resolve('You are Administrator');

    } else {
        // setTimeout(reject, 1000, 'You are not Administrator');
        return Promise.reject('You are not Administrator');

    }
}
//
// getUser(user => {
//     //call login function with three parameters
//     login(user, status => {
//         showPage(status, isAdmin => {
//             console.log(isAdmin)
//         }, err => console.log(err));
//     }, err => console.log(err));
// }, err => console.log(err));

// getUser()
//     .then(user => {
//         return login(user) //returns promise
//     })
//     .then(status => {
//         return showPage(status) //returns Promise
//     })
//     .then(log)
//     .catch(log)
//     .finally(() => console.log('Program is terminted'))


getUser()
    .then(user => login(user))//returns promise
    .then(status => showPage(status)) //returns Promise
    .then(log)
    .catch(log)
    .finally(() => console.log('Program is terminted'))

////////////////////////////////////////////////////////////////////////////////////////////

Promise Constructor:

1. if you want to convert any callback based aync application


Use case 1 : i want to wrap timer with promise.
...............................................

//Promise constructor 

const { log } = console;

const getUser = () => {

    return new Promise((resolve, reject) => {
        //biz logic
        let fakeUser = {
            id: 1,
            name: 'admin'
        }
        if (fakeUser) {
            setTimeout(resolve, 1000, fakeUser);
        } else {
            setTimeout(reject, 1000, { code: 500, message: 'Error' })
        }

    });

}
getUser()
    .then(log)
    .catch(log)

//////////////////////////////////////////////////////////////////////////////////////////////

mock data 

src/data/todos.js

please refer this url and copy and paste into this file
https://jsonplaceholder.typicode.com/todos

src/services/todoservice.js
const TODOS = require('../data/todos');


class TodoService {
    constructor() {
    }
    //sync api
    // findAllTodo() {
    //     return TODOS;
    // }
    //async code : with callbacks
    // findAllTodo(callback) {
    //     setTimeout(callback, 1000, TODOS)
    // }

    //async code : with promise
    findAllTodo() {
        return new Promise((resolve, reject) => {
            //async
           //any legacy async api with callback
           setTimeout(resolve, 1000, TODOS)
        })
    }
}
module.exports = new TodoService();



src/todoapp.js
const { findAllTodo } = require('./services/TodoService');

const { log } = console;

function fetchAllTodos() {

    //sync call
    //findAllTodo().forEach(log)
    //async call :using callbacks
    // findAllTodo(todos => {
    //     todos.forEach(log);
    // });
    //async call : using Promises
    findAllTodo().then(todos => {
        todos.forEach(log);
    });
}

//call
fetchAllTodos();

/////////////////////////////////////////////////////////////////////////////////////////

Promise Hell:
............

How to solve promise?


if you handle promises with nested way, it also creates complexity, this is called promise hell.

we are going to use promise but we are going to simplify promise handling.

getUser()
    .then(user => login(user))//returns promise
    .then(status => showPage(status)) //returns Promise
    .then(log)
    .catch(log)
    .finally(() => console.log('Program is terminted'))

How we can remove this code? 

async and await keywords

async is keyword used in front function : async functions


//async await 


const { log } = console

//Service api
const getUser = () => {
    let fakeData = {
        id: 1,
        name: 'admin'
    }
    // let fakeData = null;//false
    //biz logic
    if (fakeData) {
        // setTimeout(resolve, 1000, fakeData);
        return Promise.resolve(fakeData);
    } else {
        // setTimeout(reject, 1000, { code: 500, message: 'User not found' });
        return Promise.reject({ code: 500, message: 'User not found' });
    }
};

const login = user => {
    //biz logic
    if (user.name === 'admin') {
        // setTimeout(resolve, 1000, { code: 200, message: 'Login Success' });
        return Promise.resolve({ code: 200, message: 'Login Success' });

    } else {
        // setTimeout(reject, 1000, { code: 500, message: 'Login failed' });
        return Promise.reject({ code: 500, message: 'Login failed' });

    }
};

const showPage = loginStatus => {
    //biz
    if (loginStatus.code === 200) {
        //setTimeout(resolve, 1000, 'You are Administrator');
        return Promise.resolve('You are Administrator');

    } else {
        // setTimeout(reject, 1000, 'You are not Administrator');
        return Promise.reject('You are not Administrator');

    }
}

//Controller api
async function UserController() {

    // getUser()
    //     .then(log)
    //     .catch(log)
    //     .finally(() => console.log('finally'))

    // getUser()
    // .then(user => login(user))//returns promise
    // .then(status => showPage(status)) //returns Promise
    // .then(log)
    // .catch(log)
    // .finally(() => console.log('Program is terminted'))

    getUser()
    .then(user => login(user))//returns promise
    .then(status => showPage(status)) //returns Promise
    .then(log)
    .catch(log)
    .finally(() => console.log('Program is terminted'))


    try {
        const user = await getUser() // then
        const status = await login(user) //then
        const page = await showPage(status); //then
        console.log(page);
    }
    catch (err) { // .catch
        log(err)
    }
    finally {
        log('Program terminiated')
    }

}
UserController();
//////////////////////////////////////////////////////////////////////////////////////////

Node topics;

1.how to run js code on node

1.node program.js
2.node REPL- Read Evulate print loop


Node and javascript objects:
............................

javascript offers lot of built in objects

pojo
 Math
 Object
 Date
 JSON
 wrapper objects Number,String,Boolean
 ........
dom objects
 HtmlDocument - document
 Window
 History
 any html elements

dom related object not supported in node.


Point:

1.in browser window is global object.

2. in node "Process" is global object


//Adding env variable in programm

//get process object and set variable

process.env.mode = "Dev";
//process.env.port = 8080;
const port  = process.env.port || 9090
console.log(process.env.mode)
console.log(port)

//////////////////////////////////////////////////////////////////////////////////////////

Node and Modularity:
....................

node is highly modular platform, you can write modular applications
node by default supports cjs module system.

in node module is called "node module'


Types of modules:

1.Custom module
  Written you , eg: OrderController....
  exports,module.exports
2.in built modules
   Modules are supplied by node , which are supplied during node installation.
3.Third party modules
   provided by third parties, like frameworks,libs etc...



1.Custom module : discussed already.

2.in built modules


In built Modules:

1.OS
 Operating system information

//import os module
const {arch,cpus} = require('os');

//os system information

const { log } = console;

log('os information')
log(arch())
log(cpus())


 require('./OrderRepository');
  ->here you can see ./
  ./ -current dir
 require('os'); => 
  -here no ./ 

 Why?

Note : if you are java devp, you know the classpath , how it works?

require('os');
 if you dont tell with './'
    Node internally uses a search algorthim,node always looks the folder called
 "node_modules" in the current project, if not , then it searches, the node in built installtion folder---c:/pf/node/node_nodules--if it finds it will pick up from there else it will throw error.

 os--local node_module foder
		if not
		   c/pf/node_module
			load from there


if module not found , node will throw error
internal/modules/cjs/loader.js:800
    throw err;
    ^

Error: Cannot find module 'osccc'
Require stack:
- C:\session\ibm\mynode-app\src\index.js
[90m    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:797:15)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:690:27)[39m
[90m    at Module.require (internal/modules/cjs/loader.js:852:19)[39m
[90m    at require (internal/modules/cjs/helpers.js:74:18)[39m
    at Object.<anonymous> (C:\session\ibm\mynode-app\src\index.js:2:21)
[90m    at Module._compile (internal/modules/cjs/loader.js:959:30)[39m
[90m    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)[39m
[90m    at Module.load (internal/modules/cjs/loader.js:815:32)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:727:14)[39m
[90m    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)[39m {
  code: [32m'MODULE_NOT_FOUND'[39m,
  requireStack: [ [32m'C:\\session\\ibm\\mynode-app\\src\\index.js'[39m ]


//import os module
const {arch,cpus} = require('os');  //load from node_modules folder
const {findAll} = require('./services/TodoService') //load from current project dir

//os system information

const { log } = console;

log('os information')
log(arch())
log(cpus())
///////////////////////////////////////////////////////////////////////////////////////////

EventEmitter: How to write event driven programming.

 It is used to build driven programming.
 In node js most io applications are event driven.

Here we are going to talk how to write custom events.


//event driven programming
const EventEmitter = require('events') //returns function/class
const { log } = console;
/**
 * Event driven programming actors
 *  1.publisher
 *     publish data , send signal(event) when certain activity is finished
 *  2.consumer/listener
 *    listens for data , data is available based on event published
 */

//Create EventEmitter object
const emitter = new EventEmitter();

//Register subscribers
emitter.on('greet', function (data) {
    log(data)
});

//publisher: emit event(greet event),send data
setTimeout(() => {
    emitter.emit('greet', 'Welcome')
}, 1000)
//////////////////////////////////////////////////////////////////////////

class TriggerService extends EventEmitter {
    constructor() {
        super();
        //Register subscribers
        this.on('warning', function (data) {
            log(data)
        });
    } 
    trigger(message) {
        //emit some event
        this.emit('warning', message);
    }
}
let triggerService = new TriggerService();
setTimeout(() => {
    triggerService.trigger('Stay Home,Save Life')
}, 2000)


/////////////////////////////////////////////////////////////////////////////////////////

Async Programming in IO: Non blocking IO:

IO : INPUT AND OUTPUT =>READ AND WRITE

int a =10; //in memory : write : writing 10 value into a'address
log a =>read

IO is every where.

IN general all pl, uses blocking/sync mode of reading and writing.
in java, java creates a thread to read or write
 web programming , tomcat creates thread to handle request-response -(io)
         request -- read
         response - write
where as non blocking arch(nodejs,vertx), to read and write ,done by os kernal threads

Node non blocking io apis

1.fs io
   -files system 
2.network io
  -http : web apps
  -tcp
  -udp



const fs = require('fs');



const path = './src/assets/info.txt';
const config = {
    encoding: 'UTF-8'
}

class FileService {
    constructor() {

    }
    //api callback based file read api
    fetchFileContent(handler) {
        fs.readFile(path, config, handler);
    }
    fetchFileContentPromise() {

        //return promise
        return new Promise((resolve, reject) => {

            fs.readFile(path, config, (err, data) => {

                if (err) {
                    reject(err);
                }
                resolve(data);

            });
        });
    }
}

module.exports = new FileService();


const { fetchFileContent, fetchFileContentPromise } = require('./services/FileService');


const { log } = console;

//method : callback driven
function fetchFileCallback() {
    log('callback based')
    fetchFileContent((err, data) => {
        if (err) throw err;
        console.log(data);
    });
}
function fetchFilePromise() {
    log('promise based')
    fetchFileContentPromise()
        .then(log)
        .catch(log)
        .finally(() => log('file operation done!'))
}
async function fetchFileAsync() {
    log('async await based')
    try {
        const filecontent = await fetchFileContentPromise()
        log(filecontent);
    }
    catch (err) {
        log(err)
    }
    finally {
        log('file operation done!')
    }

}

fetchFileCallback();
fetchFilePromise()
fetchFileAsync();
///////////////////////////////////////////////////////////////////////////////////////

how to write file

//fs.js : non block io
const fs = require('fs');

//write file
const writeFilepath = './src/assets/info-copy.txt';

const data = 'This is node IO file!';

console.log('start')

fs.writeFile(writeFilepath, data, function (err) {
    if (err) throw err;
    console.info(`The file ${writeFilepath} has been written!`)
});
console.log('end')
///////////////////////////////////////////////////////////////////////////////////////

Does node support blocking IO?

Blocking io means

  readFile----stackframe --read file

All blocking io operations are handled by libuv thread pools.
 when you read, node will assign a thread  to read / write file.

Note:
1.Dont use blocking io apis for big files
2.Dont use blocking io apis in network applications.
3.Node supports only disk file io in blocking mode, not network apis


Blocking io dont have callbacks.


Node blocking io Operations:
.........................

fs.readFileSync()
fs.writeFileSync()

const fs = require('fs');

const filePath = './src/assets/info.txt';
const config = {
    encoding: 'UTF-8'
}

console.log('start');
const data = fs.readFileSync(filePath, config);
console.log(data);
console.log('end')
//////////////////////////////////////////////////////////////////////////////////////////////

Global Variables:

1.__dirname
      ->Get current dir path
2.__filename
     ->Get current dir + path__filename
     ->Get current dir + path


Use Case:
  current dir + fileName
	dir/src + fileName

//fs.js : non block io
const fs = require('fs');
const path = require('path');

/* console.log(__dirname)
console.log(__filename) */

path module
The path module provides utilities for working with file and directory paths in platform
independant way.

const fs = require('fs');
const path = require('path');


console.log(__dirname)
console.log(__filename)

//const filePath = './src/assets/info.txt';
//const filePath = __dirname + '/assets/info.txt';
const filePath = path.join(__dirname,'assets/info.txt')
const config = {
    encoding: 'UTF-8'
}

console.log('start');
const data = fs.readFileSync(filePath, config);
console.log(data);
console.log('end')
///////////////////////////////////////////////////////////////////////////////////////////

Async io operations can be done two ways.

1.Non-Streaming
2.Streaming  : Evented IO : Event driven IO.

Non Streaming IO : read / write

non streaming vs streaming:

The operating system completes the whole file read operation, sends to node process memory  , and finally will be delivered to user
  if more files , then process will be halt.

Non streaming apis are not suitable for network concurrent file operations.

What is the solution?

Streaming

Packet===breaking content into smaller units each unit is called packet.

node breaks content into smaller unit called "chunk"
node streams /send data in order chunk by chunk.



Types of Streams:

1.Readaable Stream : input
2.Writeable stream : output
3.Duplex stream : read + output


Built in readable Streams:

HTTP responses, on the client
HTTP requests, on the server
fs read streams
zlib streams
crypto streams
TCP sockets
child process stdout and stderr
process.stdin

Writable Streams:

HTTP requests, on the client
HTTP responses, on the server
fs write streams
zlib streams
crypto streams
TCP sockets
child process stdin
process.stdout, process.stderr

All streaming apis are powered with events
node io streams has built in events.
events are emitted by node.
Our programs are listeners


common events in all io

data event:
 which is emitted by node, for each chunk.

close event:
The 'close' event is emitted when the stream and any of its underlying resources (a file descriptor, for example) have been closed.

end event:
The 'end' event is emitted when there is no more data to be consumed from the stream.

Event: 'error'
 The 'error' event may be emitted by a Readable implementation at any time
Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure, or when a stream implementation attempts to push an invalid chunk of data.

//how to read /write file using streams
//streams are powered events : evented io
const fs = require('fs')
const path = require('path');
const { log } = console;

const fileName = path.join(__dirname, 'assets/info.txt');
const config = {
    encoding: 'UTF-8'
}
//read stream
const inputStream = fs.createReadStream(fileName, config);

//where we have to read data ? inside data event or end

//data event is emitted by os for each chunk of data
let data = ''
inputStream.on('data', function (chunk) {
    log(`Received ${chunk.length} bytes of data.`)
    data += chunk;
})

//end event is called , no more chunk of data is availble.
inputStream.on('end', function () {
    log('There will be no more data to read!');
    log(data);
})

//error event: for error handling
inputStream.on('error', function (err) {
    log(`Some thing went wrong! ${err}`)
});
//////////////////////////////////////////////////////////////////////////////////////////////
const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'assets/grains.txt');
const config = {
    encoding: 'utf8',
    flag: 'w'
};
const grains = ['wheat', 'rice', 'oats'];

const outputStream = fs.createWriteStream(fileName, config);

while (grains.length) {
    let data = grains.pop() + " ";
    outputStream.write(data);
    console.log("Wrote: %s", data);
}
outputStream.close();

outputStream.on('close', function () {
    console.log('file has been closed ')
});
////////////////////////////////////////////////////////////////////////////////////////////

How to read from one file and write into file? ===> Read + Write

//Read + write : simple eg:
//read + write
const fs = require('fs');
const path = require('path');

//read
const inputfileName = path.join(__dirname, 'assets/info.txt');
//write
const outputFileName = path.join(__dirname, 'assets/greeter.txt');

const config = {
    encoding: 'UTF-8'
}

const inputStream = fs.createReadStream(inputfileName, config);
const outputStream = fs.createWriteStream(outputFileName, config);

//Register data event.
inputStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);
    console.log(chunk);
    outputStream.write(chunk);
});


//end event
inputStream.on('end', function () {
    console.log('There will be no more data to read!');
    outputStream.close();
})

//error event: for error handling
inputStream.on('error', function (err) {
    console.log(`Some thing went wrong! ${err}`)
});

outputStream.on('close', function () {
    console.log(`File write operation is completed`);
});
//////////////////////////////////////////////////////////////////////////////////////////

Back Pressure:
..............
Problems when you do read and write together

1. In general read operation is faster than write operation


Back Pressure means inputstream is fast, outputstream slow, then data will be
lost.


Handling back pressure:
.......................
Pause Input stream if the Node Process memory is full(Buffer),resume if buffer/process memory is empty.

stream.pause() if stream is full
else
stream.resume() if stream is drain

big file creation:
const fs = require('fs');
const path = require('path')

const filePath = path.join(__dirname, "assets/big.file")
const file = fs.createWriteStream(filePath);

for (let i = 0; i <= 1e6; i++) {
    file.write('Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n');
}

file.end();



back pressure:
const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
const outputfileName = path.join(__dirname, 'assets/big_copy.file');

const config = {
    encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);

readerStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);

    let buffer_good = writeStr.write(chunk);

    if (!buffer_good) readerStream.pause();
});
writeStr.on('drain', function () {
    console.log('buffer drained!');
    readerStream.resume();
});

readerStream.on('end', function () {
    //console.log(data);
});

readerStream.on('error', function (err) {
    console.log(err.stack);
});



const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'big.file');
const outputfileName = path.join(__dirname, 'big_copy.file');

const config = {
      encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);

//backPressure streams
//pipe method is simplest method which wraps resume,pasuse,drain 
readerStream.pipe(writeStr);

////////////////////////////////////////////////////////////////////////////////////////////

network programming : web programming ; http

http module
//node - we create web server, web app, and we deploy 
const http = require('http');
//http is duplex streaming module : read(request) and write(reponse)
//in http every thing is object, which are created alredy , just we are using
//http since stream, which has lot events.

const { log } = console;
const port = process.env.port || 3000

//create server
const server = http.createServer(function (req, res) {
    //send response to client
    res.write('hello Node web server!');
    res.end();
});


//start server
server.listen(port, function () {
    log(`Server is listening at ${port}`)
});

//request event
server.on('request', function (req, res) {
    log(`${req.method} - ${req.url} `)
});

////////////////////////////////////////////////////////////////////////////////////////////
sending json data to json

//node - we create web server, web app, and we deploy 
const http = require('http');
const { findAllTodo } = require('./services/TodoService')
//http is duplex streaming module : read(request) and write(reponse)
//in http every thing is object, which are created alredy , just we are using
//http since stream, which has lot events.

const { log } = console;
const port = process.env.port || 3000

//create server
const server = http.createServer(async function (req, res) {
    // findAllTodo().then(todos => {
    //     //convert toddos into json
    //     const jsonTodos = JSON.stringify(todos)
    //     res.writeHead(200, {
    //         'Content-Type': 'application/json'
    //     })
    //     res.write(jsonTodos);
    //     res.end();
    // });
    
    const todos = await findAllTodo()
    console.log('Hello')
    const jsonTodos = JSON.stringify(todos)
    res.writeHead(200, {
        'Content-Type': 'application/json'
    })
    res.write(jsonTodos);
    res.end();
});


//start server
server.listen(port, function () {
    log(`Server is listening at ${port}`)
});

//request event
server.on('request', function (req, res) {
    log(`${req.method} - ${req.url} `)
});

Tradtional web work flow

Client-----request----------------WebServer--- thread--will io operation.
Client-----request----------------WebServer----thread--will io operation.
Client-----request----------------WebServer---thread-- will io operation.
Client-----request----------------WebServer---thread-- will io operation.



Non Blocking web model(Node.js):
...............................

Client-----request------WebServer built by node---|-            will io operation.
Client-----request------WebServer built by node---|- libvu --os will io operation.
Client-----request----- WebServer built by node---|-            will io operation.
Client-----request----- WebServer built by node---|-            will io opeeration


IS it possible to build real time web apps by using just pure http module alone?

 Yes! but it is very complex

node modules types
1.custom module - discussed
2.in built modules - disucssed
3.third party modules - 


Third party modules :
 created by others , we are going to use them.
 like libs,frameworks....


Where is third moudles are located?
what if i want to share my module to other developers?

mvnrepository ==maven ==third party jar files

https://www.npmjs.com/

how to download third party modules into our application? How to push our module to this rep?

javascript uses tool called "npm".

node package manager:

npm is tool is used to distribute node modules to others
and you can get node modules from other others.

npm tool is distributed along with node installation

npm uses public repository server called npmjs.com npmjs.org

tools and libs,frameworks all are distributed as node modules into repository.

Java script application :

Javascript Project Structure:(server side/ client side)
.........................................................


The project must have two things

1.package.json file :
   meta file which describes the project information
2.node_modules folder
   which contains libs/frameworks/tools code.

create package.json file

>npm init

{
  "name": "mynode-app",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}

npm is used

to install,uninstall,publish node modules from node repo / into node repo.

if you install third party modules , into your project, node distributes npm tool ,using this you can install,uninstall,upgrade node modules.



npm syntax:

npm commandName.

node_modules : folder which can hold all javascript modules downloaded from repo.


installing module:

>npm install  moduleName  --options
>npm i moduleName --options

>npm install module 
  here no option is told, means default is --save

>npm i module

options:
 --save ; 
 --save-dev
 -g

Development

Production

if you are installing any node module, you can tell, do you want to use only for development
or development + production.

Unit testing libs : Junit.jar===>java

 --save = >    development + production
 --save-dev => only for development

Which code need not be used for production:

1.All testing related  libs/frameworks - unit,e2s
2.Tools like compilers,frameworks related code.

Who will separate out this depedency(lib) for production/dev

 Build tools -  webpack.
 webpack will scan package.json---extracting prod depedencies

Demo:
....

>npm install lodash --save 

"dependencies": {
    "lodash": "^4.17.15"
  }

any thing inside this depdenencies will be used in dev + production

//
const array = require('lodash/array'); //

const list = [1, 2, 3];

array.fill(list, 'a');
console.log(list);

///////////////////////////////////////////////////////////////////////////////////////////

Unit testing Env:

->chai.js

npm install chai --save-dev

"devDependencies": {
    "chai": "^4.2.0"
  }

any thing inside this depdenencies will be used in dev only

///////////////////////////////////////////////////////////////////////////////////////

-g : global dependencies:
..........................
global package : package will be installed globally 
 inside c drive.
 looks like exe/bat files in windows

global packages not used for development(coding)

tools
 ->build system
 ->servers - webservers,testing servers
 ->compilers : babel,tsc....

Tool:

Unit Testing Server:

Mocha -server
chai - for coding assertion lib


npm install --global mocha
npm install --g mocha

C:\Users\sasub\AppData\Roaming\npm\mocha

how to run mocha?

test/hello.spec.js
//Unit testing

var assert = require('assert');
describe('Array', function () {
    describe('#indexOf()', function () {
        it('should return -1 when the value is not present', function () {
            assert.equal([1, 2, 3].indexOf(4), -1);
        });
    });
});

C:\session\ibm\mynode-app>mocha


  Array
    #indexOf()
      √ should return -1 when the value is not present


  1 passing (4ms)
///////////////////////////////////////////////////////////////////////////////////////////

Automation: scripts;
....................

Problems with Global Modules:
..............................

1.version and compablity issue for new projects

solution: 
 install those golbal tools as local dev modules

g vs --save-dev:

global dependencies not good for multiple sharing projects
install tools as project specific. --save-dev

>npm i mocha --save-dev


 single command trigger workflows

 "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  }


"scripts": {
    "commandName": "task to be automated"
}

commandname can be provided by npm called built in commands

eg:
start
test
postinstall
preinstall

custom commands also possible.

"subu" : "node src/server.js"

How to execute this command?

incase built in command

 >npm commandName
 >npm test

incase user defined command

 >npm run commandName
 >npm run subu

//////////////////////////////////////////////////////////////////////////////////////////

webpack : build system

//es 6 module

class WelcomeService {
    constructor() {

    }
    sayHello() {
        return 'hello'
    }
}
export { WelcomeService };

import { WelcomeService } from './services/WelcomeService';

//create Object

let service = new WelcomeService();
console.log(service.sayHello());


npm i webpack webpack-cli --save-dev

webpack.config.js
const path = require('path');

module.exports = {
    entry: './src/index.js',
    mode: 'production',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
    }
};



package.json
{
  "name": "mynode-app",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "mocha",
    "subu": "node src/index.js",
    "build": "webpack"
  },
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "lodash": "^4.17.15"
  },
  "devDependencies": {
    "chai": "^4.2.0",
    "mocha": "^7.1.2",
    "webpack": "^4.43.0",
    "webpack-cli": "^3.3.11"
  }
}











